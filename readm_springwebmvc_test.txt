
JUnit Testing with Spring
-------------------------

http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/testing.html

There are two ways to test Spring MVC code.
1) By loading the ContextConfigurations.
   If you just want load entire context of your webapp written in spring-boot, you might say
   @ContextConfiguration(classes = { Application.class }) where Application.java has topmost configuration that includes all other configurations.
   @SpringApplicationConfiguration can be an alternative to this.
   or
   @ContextConfiguration(classes = {DaoConfiguration.class,...})  - you can also use xml if you want
    This one is to create test application context only with a few configuration classes.

2) Use StandaloneMockMvcBuilder
   This allows you to put the required controller that you want to test with/without its dependencies like HandlerInterceptors, ControllerAdvices (RequestBodyAdvice, ResponseBodyAdvice) etc.

   e.g.
   MockMvc mockMvc = standaloneSetup(new NewCarIqOfferController()).
                           addInterceptors(newCarIqOfferControllerHandlerInterceptor).
                           setControllerAdvice(requestBodyAdvice).
                           addFilters(...).
                           ...
                           alwaysDo(print()).build();


JUnit runs unit tests using this SpringJUnit4ClassRunner.
SpringJUnit4ClassRunner has TestContextManager that creates TestContext.
TestContext builds MergedContextConfiguration that has all information (testClass,ContextLoader,contextInitializerClasses,active profiles,spring file locations and classes etc) required to run a test.
ContextLoaderUtils.buildMergedContextConfiguration method is used to build it. It has a method resolveContextLoader that actually detects @WebAppConfiguration annotation on test class and uses WebDelegatingSmartContextLoader to create WebApplicationContext instead of ApplicationContext. WebApplicationContext has ServletContext in it. MockServletContext is injected to WebApplicationContext for testing.
Using @ContextConfiguration, locations/classes are populated in MergedContextConfiguration.

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = { "/applicationContext-test-integration.xml" })
@WebAppConfiguration --- It is required to test the web controllers. @WebAppConfiguration must be used in conjunction with @ContextConfiguration.



If you want to use spring-boot's testing framework
http://javabeat.net/spring-boot-testing/

<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-test</artifactId>
</dependency>

Instead of using @ContextConfiguration, use @SpringApplicationConfiguration(classes = Application.class)
Application.java will have context configuration.

Spring Boot provides a @SpringApplicationConfiguration annotation as an alternative to the standard @ContextConfiguration annotation.
If you use @SpringApplicationConfiguration to configure the ApplicationContext used in your tests, it will be created via SpringApplication and you will get the additional Spring Boot features.
The external properties with profiling, logging and other features of Spring Boot are only installed in the context by default if you use SpringApplication to create it.



@EnableAutoConfiguration
@Configuration
@Import(value = {RestConfiguration.class})
@ComponentScan(basePackages = {"com.cobalt.services.webmvc.restclient","com.cobalt.services.application.proxies"})
public class Application {

    public static void main(String[] args) throws Exception {
        new SpringApplicationBuilder(Application.class)
                //.profiles("test") // This will make 'test' profile active. You can do the same thing at test level using @ActiveProfiles("test")
                .run(args);
    }

}

@RunWith(SpringJUnit4ClassRunner.class)
@ActiveProfiles("test") // Activate "test" profile while running this test
//@ContextConfiguration(classes = {Application.class})
@SpringApplicationConfiguration(classes = Application.class)
public class DealerServiceIntegrationTest {
    @Autowired
    private IDealerServiceProxy dealerServiceProxy;

    @Test
    public void test() {
        dealerServiceProxy.loadDealersInformation();
        assertTrue(dealerServiceProxy.hasDealers());
    }
}